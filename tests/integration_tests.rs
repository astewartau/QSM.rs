//! Integration tests for QSM-core algorithms
//!
//! These tests use synthetic ground truth data generated by a QSM forward model.
//! Each algorithm is tested independently against the appropriate ground truth.

mod common;

use std::time::Instant;
use common::{TestData, TestResult};
use qsm_core::bgremove;
use qsm_core::inversion;

/// Helper macro to run an algorithm with timing and logging
macro_rules! run_timed {
    ($name:expr, $code:expr) => {{
        println!("[INFO] Starting {}...", $name);
        let start = Instant::now();
        let result = $code;
        let elapsed = start.elapsed();
        println!("[INFO] {} completed in {:.2?}", $name, elapsed);
        (result, elapsed)
    }};
}

// ============================================================================
// Background Removal Tests
// ============================================================================

#[test]
#[ignore] // Run with: cargo test --test integration_tests -- --ignored
fn test_bgremove_sharp() {
    println!("[INFO] Loading test data...");
    let data = TestData::load().expect("Failed to load test data");
    let (nx, ny, nz) = data.dims;
    let (vsx, vsy, vsz) = data.voxel_size;

    let ((result, _new_mask), elapsed) = run_timed!("SHARP", bgremove::sharp(
        &data.fieldmap,
        &data.mask,
        nx, ny, nz,
        vsx, vsy, vsz,
        6.0,   // radius in mm
        0.05,  // threshold
    ));

    let res = TestResult::new("SHARP", &result, &data.fieldmap_local, &data.mask);
    res.print_with_time(elapsed);
    res.print_ci_metrics(elapsed);
    common::save_center_slices(&result, &data.mask, data.dims, "bgremove_sharp");

    assert!(res.nrmse < 0.5, "SHARP NRMSE too high: {}", res.nrmse);
    assert!(res.correlation > 0.7, "SHARP correlation too low: {}", res.correlation);
}

#[test]
#[ignore]
fn test_bgremove_vsharp() {
    println!("[INFO] Loading test data...");
    let data = TestData::load().expect("Failed to load test data");
    let (nx, ny, nz) = data.dims;
    let (vsx, vsy, vsz) = data.voxel_size;

    // V-SHARP with multiple radii
    let radii: Vec<f64> = (1..=12).map(|r| r as f64).collect();

    let ((result, _new_mask), elapsed) = run_timed!("V-SHARP", bgremove::vsharp(
        &data.fieldmap,
        &data.mask,
        nx, ny, nz,
        vsx, vsy, vsz,
        &radii,
        0.05,  // threshold
    ));

    let res = TestResult::new("V-SHARP", &result, &data.fieldmap_local, &data.mask);
    res.print_with_time(elapsed);
    res.print_ci_metrics(elapsed);
    common::save_center_slices(&result, &data.mask, data.dims, "bgremove_vsharp");

    assert!(res.nrmse < 0.5, "V-SHARP NRMSE too high: {}", res.nrmse);
    assert!(res.correlation > 0.7, "V-SHARP correlation too low: {}", res.correlation);
}

#[test]
#[ignore]
fn test_bgremove_pdf() {
    println!("[INFO] Loading test data...");
    let data = TestData::load().expect("Failed to load test data");
    let (nx, ny, nz) = data.dims;
    let (vsx, vsy, vsz) = data.voxel_size;

    let (result, elapsed) = run_timed!("PDF", bgremove::pdf(
        &data.fieldmap,
        &data.mask,
        nx, ny, nz,
        vsx, vsy, vsz,
        data.b0_dir,
        1e-6,  // tolerance
        100,   // max iterations
    ));

    let res = TestResult::new("PDF", &result, &data.fieldmap_local, &data.mask);
    res.print_with_time(elapsed);
    res.print_ci_metrics(elapsed);
    common::save_center_slices(&result, &data.mask, data.dims, "bgremove_pdf");

    assert!(res.nrmse < 0.5, "PDF NRMSE too high: {}", res.nrmse);
    assert!(res.correlation > 0.7, "PDF correlation too low: {}", res.correlation);
}

#[test]
#[ignore]
fn test_bgremove_ismv() {
    println!("[INFO] Loading test data...");
    let data = TestData::load().expect("Failed to load test data");
    let (nx, ny, nz) = data.dims;
    let (vsx, vsy, vsz) = data.voxel_size;

    let ((result, _new_mask), elapsed) = run_timed!("iSMV", bgremove::ismv(
        &data.fieldmap,
        &data.mask,
        nx, ny, nz,
        vsx, vsy, vsz,
        5.0,   // radius in mm
        1e-6,  // tolerance
        50,    // max iterations
    ));

    let res = TestResult::new("iSMV", &result, &data.fieldmap_local, &data.mask);
    res.print_with_time(elapsed);
    res.print_ci_metrics(elapsed);
    common::save_center_slices(&result, &data.mask, data.dims, "bgremove_ismv");

    assert!(res.nrmse < 0.5, "iSMV NRMSE too high: {}", res.nrmse);
    assert!(res.correlation > 0.7, "iSMV correlation too low: {}", res.correlation);
}

#[test]
#[ignore]
fn test_bgremove_lbv() {
    println!("[INFO] Loading test data...");
    let data = TestData::load().expect("Failed to load test data");
    let (nx, ny, nz) = data.dims;
    let (vsx, vsy, vsz) = data.voxel_size;

    let ((result, _new_mask), elapsed) = run_timed!("LBV", bgremove::lbv(
        &data.fieldmap,
        &data.mask,
        nx, ny, nz,
        vsx, vsy, vsz,
        1e-6,  // tolerance
        100,   // max iterations
    ));

    let res = TestResult::new("LBV", &result, &data.fieldmap_local, &data.mask);
    res.print_with_time(elapsed);
    res.print_ci_metrics(elapsed);
    common::save_center_slices(&result, &data.mask, data.dims, "bgremove_lbv");

    assert!(res.nrmse < 0.5, "LBV NRMSE too high: {}", res.nrmse);
    assert!(res.correlation > 0.7, "LBV correlation too low: {}", res.correlation);
}

// ============================================================================
// Dipole Inversion Tests
// ============================================================================

#[test]
#[ignore]
fn test_inversion_tkd() {
    println!("[INFO] Loading test data...");
    let data = TestData::load().expect("Failed to load test data");
    let (nx, ny, nz) = data.dims;
    let (vsx, vsy, vsz) = data.voxel_size;

    let (result, elapsed) = run_timed!("TKD", inversion::tkd(
        &data.fieldmap_local,
        &data.mask,
        nx, ny, nz,
        vsx, vsy, vsz,
        data.b0_dir,
        0.2,  // threshold
    ));

    let res = TestResult::new("TKD", &result, &data.chi, &data.mask);
    res.print_with_time(elapsed);
    res.print_ci_metrics(elapsed);
    common::save_center_slices(&result, &data.mask, data.dims, "inversion_tkd");

    assert!(res.nrmse < 0.5, "TKD NRMSE too high: {}", res.nrmse);
    assert!(res.correlation > 0.7, "TKD correlation too low: {}", res.correlation);
}

#[test]
#[ignore]
fn test_inversion_tsvd() {
    println!("[INFO] Loading test data...");
    let data = TestData::load().expect("Failed to load test data");
    let (nx, ny, nz) = data.dims;
    let (vsx, vsy, vsz) = data.voxel_size;

    let (result, elapsed) = run_timed!("TSVD", inversion::tsvd(
        &data.fieldmap_local,
        &data.mask,
        nx, ny, nz,
        vsx, vsy, vsz,
        data.b0_dir,
        0.2,  // threshold
    ));

    let res = TestResult::new("TSVD", &result, &data.chi, &data.mask);
    res.print_with_time(elapsed);
    res.print_ci_metrics(elapsed);
    common::save_center_slices(&result, &data.mask, data.dims, "inversion_tsvd");

    assert!(res.nrmse < 0.5, "TSVD NRMSE too high: {}", res.nrmse);
    assert!(res.correlation > 0.7, "TSVD correlation too low: {}", res.correlation);
}

#[test]
#[ignore]
fn test_inversion_tikhonov() {
    println!("[INFO] Loading test data...");
    let data = TestData::load().expect("Failed to load test data");
    let (nx, ny, nz) = data.dims;
    let (vsx, vsy, vsz) = data.voxel_size;

    let (result, elapsed) = run_timed!("Tikhonov", inversion::tikhonov(
        &data.fieldmap_local,
        &data.mask,
        nx, ny, nz,
        vsx, vsy, vsz,
        data.b0_dir,
        1e-3,  // lambda
        inversion::tikhonov::Regularization::Gradient,
    ));

    let res = TestResult::new("Tikhonov", &result, &data.chi, &data.mask);
    res.print_with_time(elapsed);
    res.print_ci_metrics(elapsed);
    common::save_center_slices(&result, &data.mask, data.dims, "inversion_tikhonov");

    assert!(res.nrmse < 0.5, "Tikhonov NRMSE too high: {}", res.nrmse);
    assert!(res.correlation > 0.7, "Tikhonov correlation too low: {}", res.correlation);
}

#[test]
#[ignore]
fn test_inversion_tv() {
    println!("[INFO] Loading test data...");
    let data = TestData::load().expect("Failed to load test data");
    let (nx, ny, nz) = data.dims;
    let (vsx, vsy, vsz) = data.voxel_size;

    let (result, elapsed) = run_timed!("TV-ADMM", inversion::tv_admm(
        &data.fieldmap_local,
        &data.mask,
        nx, ny, nz,
        vsx, vsy, vsz,
        data.b0_dir,
        1e-4,  // lambda
        1.0,   // rho
        1e-4,  // tolerance
        50,    // max iterations
    ));

    let res = TestResult::new("TV-ADMM", &result, &data.chi, &data.mask);
    res.print_with_time(elapsed);
    res.print_ci_metrics(elapsed);
    common::save_center_slices(&result, &data.mask, data.dims, "inversion_tv");

    assert!(res.nrmse < 0.5, "TV-ADMM NRMSE too high: {}", res.nrmse);
    assert!(res.correlation > 0.7, "TV-ADMM correlation too low: {}", res.correlation);
}

#[test]
#[ignore]
fn test_inversion_rts() {
    println!("[INFO] Loading test data...");
    let data = TestData::load().expect("Failed to load test data");
    let (nx, ny, nz) = data.dims;
    let (vsx, vsy, vsz) = data.voxel_size;

    let (result, elapsed) = run_timed!("RTS", inversion::rts(
        &data.fieldmap_local,
        &data.mask,
        nx, ny, nz,
        vsx, vsy, vsz,
        data.b0_dir,
        0.2,   // delta (threshold)
        1e-3,  // mu
        1.0,   // rho
        1e-4,  // tolerance
        50,    // max iterations
        20,    // lsmr iterations
    ));

    let res = TestResult::new("RTS", &result, &data.chi, &data.mask);
    res.print_with_time(elapsed);
    res.print_ci_metrics(elapsed);
    common::save_center_slices(&result, &data.mask, data.dims, "inversion_rts");

    assert!(res.nrmse < 0.5, "RTS NRMSE too high: {}", res.nrmse);
    assert!(res.correlation > 0.7, "RTS correlation too low: {}", res.correlation);
}

// ============================================================================
// Full Benchmark Report
// ============================================================================

#[test]
#[ignore]
fn benchmark_all_algorithms() {
    println!("[INFO] Loading test data...");
    let load_start = Instant::now();
    let data = TestData::load().expect("Failed to load test data");
    println!("[INFO] Test data loaded in {:.2?}", load_start.elapsed());

    let (nx, ny, nz) = data.dims;
    let (vsx, vsy, vsz) = data.voxel_size;

    println!("\n{}", "=".repeat(70));
    println!("QSM-CORE ALGORITHM BENCHMARK");
    println!("Volume: {}x{}x{}, Voxel: {:.2}x{:.2}x{:.2} mm",
        nx, ny, nz, vsx, vsy, vsz);
    println!("{}\n", "=".repeat(70));

    // -------------------------------------------------------------------------
    // Background Removal
    // -------------------------------------------------------------------------
    println!("BACKGROUND REMOVAL (vs ground truth local field)");
    println!("{}", "-".repeat(70));
    println!("{:<15} {:>12} {:>10} {:>10} {:>12}", "Method", "RMSE", "NRMSE", "Corr", "Time");
    println!("{}", "-".repeat(70));

    // SHARP
    let ((result, _), elapsed) = run_timed!("SHARP", bgremove::sharp(
        &data.fieldmap, &data.mask, nx, ny, nz, vsx, vsy, vsz, 6.0, 0.05
    ));
    TestResult::new("SHARP", &result, &data.fieldmap_local, &data.mask).print_with_time(elapsed);

    // V-SHARP
    let radii: Vec<f64> = (1..=12).map(|r| r as f64).collect();
    let ((result, _), elapsed) = run_timed!("V-SHARP", bgremove::vsharp(
        &data.fieldmap, &data.mask, nx, ny, nz, vsx, vsy, vsz, &radii, 0.05
    ));
    TestResult::new("V-SHARP", &result, &data.fieldmap_local, &data.mask).print_with_time(elapsed);

    // PDF
    let (result, elapsed) = run_timed!("PDF", bgremove::pdf(
        &data.fieldmap, &data.mask, nx, ny, nz, vsx, vsy, vsz, data.b0_dir, 1e-6, 100
    ));
    TestResult::new("PDF", &result, &data.fieldmap_local, &data.mask).print_with_time(elapsed);

    // iSMV
    let ((result, _), elapsed) = run_timed!("iSMV", bgremove::ismv(
        &data.fieldmap, &data.mask, nx, ny, nz, vsx, vsy, vsz, 5.0, 1e-6, 50
    ));
    TestResult::new("iSMV", &result, &data.fieldmap_local, &data.mask).print_with_time(elapsed);

    // LBV
    let ((result, _), elapsed) = run_timed!("LBV", bgremove::lbv(
        &data.fieldmap, &data.mask, nx, ny, nz, vsx, vsy, vsz, 1e-6, 100
    ));
    TestResult::new("LBV", &result, &data.fieldmap_local, &data.mask).print_with_time(elapsed);

    // -------------------------------------------------------------------------
    // Dipole Inversion
    // -------------------------------------------------------------------------
    println!("\nDIPOLE INVERSION (vs ground truth chi)");
    println!("{}", "-".repeat(70));
    println!("{:<15} {:>12} {:>10} {:>10} {:>12}", "Method", "RMSE", "NRMSE", "Corr", "Time");
    println!("{}", "-".repeat(70));

    // TKD
    let (result, elapsed) = run_timed!("TKD", inversion::tkd(
        &data.fieldmap_local, &data.mask, nx, ny, nz, vsx, vsy, vsz, data.b0_dir, 0.2
    ));
    TestResult::new("TKD", &result, &data.chi, &data.mask).print_with_time(elapsed);

    // TSVD
    let (result, elapsed) = run_timed!("TSVD", inversion::tsvd(
        &data.fieldmap_local, &data.mask, nx, ny, nz, vsx, vsy, vsz, data.b0_dir, 0.2
    ));
    TestResult::new("TSVD", &result, &data.chi, &data.mask).print_with_time(elapsed);

    // Tikhonov
    let (result, elapsed) = run_timed!("Tikhonov", inversion::tikhonov(
        &data.fieldmap_local, &data.mask, nx, ny, nz, vsx, vsy, vsz,
        data.b0_dir, 1e-3, inversion::tikhonov::Regularization::Gradient
    ));
    TestResult::new("Tikhonov", &result, &data.chi, &data.mask).print_with_time(elapsed);

    // TV-ADMM
    let (result, elapsed) = run_timed!("TV-ADMM", inversion::tv_admm(
        &data.fieldmap_local, &data.mask, nx, ny, nz, vsx, vsy, vsz,
        data.b0_dir, 1e-4, 1.0, 1e-4, 50
    ));
    TestResult::new("TV-ADMM", &result, &data.chi, &data.mask).print_with_time(elapsed);

    // RTS
    let (result, elapsed) = run_timed!("RTS", inversion::rts(
        &data.fieldmap_local, &data.mask, nx, ny, nz, vsx, vsy, vsz,
        data.b0_dir, 0.2, 1e-3, 1.0, 1e-4, 50, 20
    ));
    TestResult::new("RTS", &result, &data.chi, &data.mask).print_with_time(elapsed);

    println!("\n{}", "=".repeat(70));
}
